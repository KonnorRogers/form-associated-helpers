{
  "version": 3,
  "sources": ["../../../../../exports/mixins/lit-textarea-mixin.js"],
  "sourcesContent": ["import { TooLongValidator } from \"../validators/too-long-validator.js\"\nimport { TooShortValidator } from \"../validators/too-short-validator.js\"\nimport { LitFormAssociatedMixin } from \"./lit-form-associated-mixin.js\"\n\nconst formProperties = () => Object.assign(\n  {\n    autocomplete: {},\n    wrap: {},\n    readOnly: {attribute: \"readonly\", type: Boolean, reflect: true},\n    placeholder: {},\n    dirName: {},\n    rows: {type: Number},\n    cols: {type: Number},\n\n    defaultValue: {attribute: \"value\", reflect: true},\n    valueHasChanged: {type: Boolean, attribute: false, state: true},\n    value: {attribute: false, state: true},\n\n    // Validation\n    maxLength: {attribute: \"maxlength\", type: Number},\n    minLength: {attribute: \"minlength\", type: Number},\n  },\n  // structuredClone so we dont have mutable properties.\n  LitFormAssociatedMixin.formProperties\n)\n\nObject.defineProperty(LitTextareaMixin, \"formProperties\", {\n  get () {\n    return formProperties()\n  }\n})\n\n/**\n * @typedef {import(\"./lit-textarea-mixin-types.js\").TextareaGetters} TextareaGetters\n */\n\n/**\n * @template {{ new (...args: any[]): HTMLElement }} T\n * @param {T} superclass\n */\nexport function TextareaGettersMixin(superclass) {\n  return /** @type {T & { new (...args: any[]): TextareaGetters}} */ (_TextareaGettersMixin(superclass))\n}\n\n/**\n * @template {{ new (...args: any[]): HTMLElement }} T\n * @param {T} superclass\n */\nfunction _TextareaGettersMixin(superclass) {\n  return (\n    /**\n     * @implements {TextareaGetters}\n     */\n    class extends superclass {\n      /**\n        * @returns {HTMLTextAreaElement[\"textLength\"]}\n        */\n      get textLength () {\n        const formControl = /** @type {any} */(this).formControl\n\n        if (formControl && \"textLength\" in formControl) {\n          return /** @type {HTMLTextAreaElement} */ (formControl).textLength\n        }\n\n        return 0\n      }\n\n      /**\n        * @returns {HTMLTextAreaElement[\"selectionStart\"]}\n        */\n      get selectionStart () {\n        const formControl = /** @type {any} */ (this).formControl\n\n        if (formControl && \"selectionStart\" in formControl) {\n          return formControl.selectionStart\n        }\n\n        return 0\n      }\n\n      /**\n        * @returns {HTMLTextAreaElement[\"selectionEnd\"]}\n        */\n      get selectionEnd () {\n        const formControl = /** @type {any} */ (this).formControl\n\n        if (formControl && \"selectionEnd\" in formControl) {\n          return formControl.selectionEnd\n        }\n\n        return 0\n      }\n\n      /**\n      * @returns {boolean}\n      */\n      get isUserInvalid () {\n        return /** @type {any} */ (this).hasInteracted && /** @type {any} */ (this).valueHasChanged\n      }\n    }\n  )\n}\n\n/**\n * A mixin for build a `<textarea>` specifically for Lit.\n *\n * @see https://webkit.org/blog/13711/elementinternals-and-form-associated-custom-elements/\n * @template {{ new (...args: any[]): HTMLElement }} T\n * @param {T} superclass\n */\nexport function LitTextareaMixin(superclass) {\n  return (\n    /**\n    * @implements HTMLTextAreaElement\n    */\n    class LitFormAssociatedClass extends TextareaGettersMixin(LitFormAssociatedMixin(superclass)) {\n      /**\n      * @override\n      * @type {Array<import(\"../types.js\").Validator>}\n      */\n      static get validators () {\n        return [\n          ...super.validators,\n          TooLongValidator(),\n          TooShortValidator(),\n        ]\n      }\n\n      static get properties () {\n        /**\n          * @type {null | import(\"lit\").PropertyValues}\n          */\n        // @ts-expect-error\n        const properties = super.properties\n        if (properties) {\n          return {...LitTextareaMixin.formProperties, ...properties}\n        }\n\n        return LitTextareaMixin.formProperties\n      }\n\n      /**\n        * @param {...any} args\n        */\n      constructor (...args) {\n        super(...args)\n\n        /**\n          * @type {HTMLTextAreaElement[\"autocomplete\"]}\n          */\n        this.autocomplete = \"\"\n\n        /**\n          * @type {HTMLTextAreaElement[\"wrap\"]}\n          */\n        this.wrap = \"\"\n\n        /**\n          * @type {string}\n          */\n        this.value = \"\"\n\n        /**\n          * @type {string}\n          */\n        this.defaultValue = \"\"\n\n        /**\n         * @type {boolean}\n         */\n        this.valueHasChanged = false\n\n        /**\n          * @type {HTMLTextAreaElement[\"maxLength\"]}\n          */\n        this.maxLength = -1\n\n        /**\n          * @type {HTMLTextAreaElement[\"minLength\"]}\n          */\n        this.minLength = -1\n\n        /**\n          * @type {HTMLTextAreaElement[\"readOnly\"]}\n          */\n        this.readOnly = false\n\n        /**\n          * @type {HTMLTextAreaElement[\"placeholder\"]}\n          */\n        this.placeholder = \"\"\n\n        /**\n          * @type {HTMLTextAreaElement[\"required\"]}\n          */\n        this.required = false\n\n        /**\n          * @type {HTMLTextAreaElement[\"dirName\"]}\n          */\n        this.dirName = \"\"\n\n        /** @type {HTMLTextAreaElement[\"selectionDirection\"]} */\n        this.selectionDirection = \"forward\"\n\n        /**\n          * @type {number}\n          */\n        this.rows = 2\n\n        /**\n          * @type {number}\n          */\n        this.cols = 20\n\n      }\n\n      /**\n       * @override\n       * @param {Event} e\n       */\n      handleInvalid (e) {\n        if (e.target !== this) return\n        if (this.isDisabled) return\n\n        this.valueHasChanged = true\n        this.hasInteracted = true\n        this.updateInteractionState()\n      }\n\n      /**\n       * @override\n       * Sets `this.hasInteracted = true` to true when the users focus / clicks the element.\n       * @param {Event} e\n       */\n      handleInteraction (e) {\n        if (this.isDisabled) return\n\n        if (!this.matches(\":focus-within\")) {\n          this.hasInteracted = true\n        }\n\n        this.updateValidity()\n      }\n\n      /**\n       * @param {string} name\n       * @param {null | string} oldVal\n       * @param {null | string} newVal\n       */\n      attributeChangedCallback (name, oldVal, newVal) {\n        if (name === \"value\") {\n          this.defaultValue = newVal || \"\"\n\n          if (!this.hasInteracted && !this.valueHasChanged) {\n            this.value = this.defaultValue\n            this.setFormValue(/** @type {any} */ (this.toFormValue()), /** @type {any} */ (this.value))\n          }\n        }\n        super.attributeChangedCallback(name, oldVal, newVal)\n      }\n\n\n      /**\n        * @param {Parameters<HTMLTextAreaElement[\"setSelectionRange\"]>} args\n        */\n      setSelectionRange (...args) {\n        const formControl = /** @type {any} */(this).formControl\n\n        if (formControl && \"selectionRange\" in formControl) {\n          /** @type {HTMLTextAreaElement} */ (/** @type {unknown} */ (formControl)).setSelectionRange?.(...args)\n        }\n      }\n\n      /**\n        * @param {[replacement: string, start: number, end: number, selectionMode?: SelectionMode] | [replacement: string]} args\n        */\n      setRangeText (...args) {\n        const formControl = /** @type {any} */ (this).formControl\n\n        if (formControl && \"setRangeText\" in formControl) {\n          // @ts-expect-error\n          /** @type {HTMLTextAreaElement} */ (/** @type {unknown} */ (formControl)).setRangeText(...args)\n        }\n      }\n\n      /**\n        * @type {HTMLTextAreaElement[\"select\"]}\n        */\n      select () {\n        const formControl = /** @type {HTMLTextAreaElement} */ (/** @type {any} */ (this).formControl)\n\n        if (formControl) {\n          formControl.select?.()\n        }\n      }\n\n      /**\n       * @override\n       */\n      formResetCallback () {\n        this.value = this.defaultValue\n\n        if (/** @type {any} */ (this).formControl)  {\n          /** @type {any} */ (this).formControl.value = this.value\n        }\n\n        this.hasInteracted = false\n        this.valueHasChanged = false\n\n        super.formResetCallback()\n      }\n\n      /**\n       * @param {Parameters<import(\"lit\").LitElement[\"willUpdate\"]>[0]} changedProperties\n       */\n      willUpdate (changedProperties) {\n        if (changedProperties.has(\"value\")) {\n          if (this.value !== this.defaultValue) {\n            this.valueHasChanged = true\n          }\n        }\n\n        if (changedProperties.has(\"defaultValue\")) {\n          if (!this.hasInteracted && !this.valueHasChanged) {\n            this.value = this.defaultValue\n            this.setFormValue(/** @type {any} */ (this.toFormValue()), /** @type {any} */ (this.value))\n          }\n        }\n\n        super.willUpdate(changedProperties)\n      }\n    }\n  )\n}\n"],
  "mappings": "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",
  "names": ["formProperties", "LitFormAssociatedMixin", "LitTextareaMixin", "TextareaGettersMixin", "superclass", "_TextareaGettersMixin", "formControl", "TooLongValidator", "TooShortValidator", "properties", "args", "e", "name", "oldVal", "newVal", "changedProperties"]
}
