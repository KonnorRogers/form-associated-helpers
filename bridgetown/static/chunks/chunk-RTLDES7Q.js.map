{
  "version": 3,
  "sources": ["../../../../../exports/mixins/vanilla-form-associated-mixin.js"],
  "sourcesContent": ["import { ValueMissingValidator } from \"../validators/value-missing-validator.js\"\nimport { CustomStatesMixin } from \"./custom-states-mixin.js\"\nimport { FormAssociatedMixin } from \"./form-associated-mixin.js\"\n\n/**\n * @typedef {import(\"./types.js\").GConstructable<HTMLElement & Partial<{ formControl?: null | undefined | (HTMLElement & { value: any, defaultValue: any })}>> & { observedAttributes?: string[] }} FormAssociatedElement\n */\n\n/**\n * A mixin of form associated helpers that get added to a class with attachInternals.\n * This opinionated version extends the above formAssociated and handles common conventions I like.\n * Required properties: { value, disabled, formControl, validationTarget }\n *\n * @see https://webkit.org/blog/13711/elementinternals-and-form-associated-custom-elements/\n * @template {FormAssociatedElement} T\n * @param {T} superclass\n */\nexport function VanillaFormAssociatedMixin(superclass) {\n  return (\n    class extends CustomStatesMixin(FormAssociatedMixin(superclass)) {\n      /**\n       * @override\n       */\n      static get observedAttributes () {\n        const parentAttrs = new Set(/** @type {string[]} */ (super.observedAttributes) || [])\n\n        for (const validator of this.validators) {\n          if (!validator.observedAttributes) { continue }\n\n          for (const attr of validator.observedAttributes) {\n            parentAttrs.add(attr)\n          }\n        }\n\n        return [...parentAttrs]\n      }\n\n\n      /**\n       * Validators are static because they have `observedAttributes`, essentially attributes to \"watch\"\n       * for changes. Whenever these attributes change, we want to be notified and update the validator.\n       * @type {Array<import(\"../types.js\").Validator>}\n       */\n      static get validators () {\n        return [\n          ValueMissingValidator()\n        ]\n      }\n\n      /**\n       * @param {...any} args\n       */\n      constructor (...args) {\n        super(...args)\n\n        /**\n         * @type {ElementInternals[\"role\"]}\n         */\n        this.role = null\n\n        /**\n         * @type {FormData | string | File | null}\n         */\n        this.value = null\n\n        /**\n         * @type {FormData | string | File | null}\n         */\n        this.previousValue = this.value\n\n        /**\n         * @type {string}\n         */\n        this.defaultValue = \"\"\n\n        /**\n         * @type {HTMLInputElement[\"name\"]}\n         */\n        this.name = \"\"\n\n        /**\n         * `this.type` is used by ElementInternals.\n         * @type {string}\n         */\n        this.type = this.localName || \"\"\n\n        /**\n         * Make sure if you're using a library that \"reflects\" properties to attributes, you don't reflect this `disabled.`\n         * @type {boolean}\n         */\n        this.disabled = false\n\n        /**\n         * Generally forms can have \"required\", this may not be necessary here, but is a nice convention.\n         * @type {boolean}\n         */\n        this.required = false\n\n        /**\n         * Tracks when a user blurs from a form control.\n         * @type {boolean}\n         */\n        this.hasInteracted = this.hasInteracted ?? false\n\n        /**\n         * Dirty tracks if the value has been changed.\n         * @type {boolean}\n         */\n        this.valueHasChanged = this.valueHasChanged ?? false\n\n        /**\n         * While not generally encouraged, you can add instance level validators.\n         *   These validators should not rely on an attribute, or should already have a \"watched\" attribute\n         *   to know when to re-run the validator.\n         * @type {Array<import(\"../types.js\").Validator>}\n         */\n        this.validators = []\n\n        // this.setFormValue(null)\n\n        // this.addEventListener(\"focusin\", this.handleInteraction)\n        this.addEventListener(\"focusout\", this.handleInteraction)\n        this.addEventListener(\"blur\", this.handleInteraction)\n        this.addEventListener(\"invalid\", this.handleInvalid)\n\n        // Private\n\n        /** This is a dirty check for custom errors. In Safari, {customError: true} always happens with `setValidity()`. This is the workaround. */\n        this.__hasCustomError = false\n        this.__customErrorMessage = \"\"\n      }\n\n      /**\n       * @param {Event} e\n       */\n      handleInvalid = (e) => {\n        if (e.target !== this) return\n        if (this.disabled === true || this.hasAttribute(\"disabled\")) return\n\n        if (this.value !== this.defaultValue) {\n          this.valueHasChanged = true\n        }\n\n        this.hasInteracted = true\n\n        this.updateInteractionState()\n      }\n\n      /**\n       * Sets `this.hasInteracted = true` to true when the users focus / clicks the element.\n       * @param {Event} e\n       */\n      handleInteraction = (e) => {\n        if (this.disabled === true || this.hasAttribute(\"disabled\")) return\n\n        if (!this.matches(\":focus-within\") && this.valueHasChanged) {\n          this.hasInteracted = true\n        }\n        this.updateValidity()\n      }\n\n      get allValidators () {\n        /**\n         * @type {Array<import(\"../types.js\").Validator>}\n         */\n        // @ts-expect-error\n        const staticValidators = this.constructor.validators || []\n\n        /**\n         * @type {Array<import(\"../types.js\").Validator>}\n         */\n        const validators = this.validators || []\n        return [...staticValidators, ...validators]\n      }\n\n      get willShowValidationMessage () {\n        return this.disabled !== true && this.hasInteracted === true\n      }\n\n      get labels () {\n        return /** @type {NodeListOf<HTMLLabelElement>} */ (this.internals.labels)\n      }\n\n      get validity () {\n        return this.internals.validity\n      }\n\n      get validationMessage () {\n        return this.internals.validationMessage\n      }\n\n      get willValidate () {\n        return this.internals.willValidate\n      }\n\n      /**\n       * This function technically does not exist with internals, but exists on native form elements.\n       *   This is backported for users familiar with the API.\n       * @param {string} message\n       */\n      setCustomValidity (message) {\n        if (!message) {\n          this.__hasCustomError = false\n          this.__customErrorMessage = \"\"\n          this.setValidity({})\n          return\n        }\n\n        this.__hasCustomError = true\n        this.__customErrorMessage = message\n        this.internals.setValidity({customError: true}, message)\n      }\n\n      /**\n       * @param {string} name\n       * @param {string} oldVal\n       * @param {string} newVal\n       */\n      attributeChangedCallback(name, oldVal, newVal) {\n        // @ts-expect-error\n        if (typeof super.attributeChangedCallback === \"function\") {\n          // @ts-expect-error\n          super.attributeChangedCallback(name, oldVal, newVal)\n        }\n\n        if (newVal === oldVal) {\n          return\n        }\n\n        if (name === \"role\") {\n          this.internals.role = newVal || null\n        }\n\n        if (name === \"value\") {\n          this.defaultValue = this.getAttribute(\"value\") || \"\"\n\n          if (!this.hasInteracted && !this.valueHasChanged) {\n            this.value = this.defaultValue\n            this.setFormValue(this.value, this.value)\n          }\n        }\n\n        this.updateValidity()\n      }\n\n      /**\n      * Called when the form is being reset. (e.g. user pressed `<input[type=reset]>` button). Custom element should clear whatever value set by the user.\n      * @returns {void}\n      */\n      formResetCallback() {\n        if (\"formControl\" in this && this.formControl) {\n          this.formControl.value = this.defaultValue\n        }\n\n        this.resetValidity()\n        this.value = this.defaultValue\n        this.hasInteracted = false\n        this.valueHasChanged = false\n        this.updateValidity()\n        this.setFormValue(this.defaultValue, this.defaultValue)\n      }\n\n      /**\n      * Called when the disabled state of the form changes\n      * @param {boolean} isDisabled\n      * @returns {void}\n      */\n      formDisabledCallback(isDisabled) {\n        this.disabled = isDisabled\n        this.resetValidity()\n        this.updateValidity()\n      }\n\n      /**\n      * Called when the browser is trying to restore element\u2019s state to state in which case reason is \u201Crestore\u201D, or when the browser is trying to fulfill autofill on behalf of user in which case reason is \u201Cautocomplete\u201D. In the case of \u201Crestore\u201D, state is a string, File, or FormData object previously set as the second argument to setFormValue.\n      * @param {string | File | FormData | null} state\n      * @param {string} reason\n      * @returns {void}\n      */\n      formStateRestoreCallback(state, reason) {\n        this.value = state\n\n        if (this.formControl) {\n          this.formControl.value = state\n        }\n\n        this.resetValidity()\n        this.updateValidity()\n\n      }\n\n      // Additional things not added by the `attachInternals()` call.\n\n      /**\n       * This should generally not be used by end users. This is intended for custom validators.\n       * @param {Parameters<ElementInternals[\"setValidity\"]>} params\n       */\n      setValidity (...params) {\n        let flags = params[0]\n        let message = params[1]\n\n        let anchor = params[2]\n\n        if (!anchor) {\n          const validationTarget = this.validationTarget\n          anchor = validationTarget\n        }\n\n        this.internals.setValidity(flags, message, anchor)\n        this.updateInteractionState()\n      }\n\n      reportValidity () {\n        this.updateValidity()\n        return this.internals.reportValidity()\n      }\n\n      checkValidity () {\n        this.updateValidity()\n        return this.internals.checkValidity()\n      }\n\n      /**\n        * `validationTarget` is used for displaying native validation popups as the \"anchor\"\n        * @type {undefined | HTMLElement}\n        */\n      get validationTarget () {\n        return this.formControl || undefined\n      }\n\n      /**\n        * @param {Parameters<ElementInternals[\"setFormValue\"]>} args\n        */\n      setFormValue (...args) {\n        // Dirty tracking of values.\n        if (this.value !== this.defaultValue) {\n          this.valueHasChanged = true\n        }\n\n        this.internals.setFormValue(...args)\n        this.updateValidity()\n      }\n\n      /**\n       * Returns the form attached to the element\n       * @returns {ReturnType<ElementInternals[\"form\"]>}\n       */\n      get form () {\n        return this.internals.form\n      }\n\n      resetValidity () {\n        this.setCustomValidity(\"\")\n        this.setValidity({})\n      }\n\n      updateValidity () {\n        if (this.disabled || this.getAttribute(\"disabled\")) {\n          this.resetValidity()\n          // We don't run validators on disabled thiss to be inline with native HTMLElements.\n          // https://codepen.io/paramagicdev/pen/PoLogeL\n          return\n        }\n\n        const validators = /** @type {{allValidators?: Array<import(\"../types.js\").Validator>}} */ (/** @type {unknown} */ (this)).allValidators\n\n        if (!validators) {\n          this.setValidity({})\n          return\n        }\n\n        const customError = Boolean(this.__hasCustomError)\n        const flags = {\n          customError\n        }\n\n        const formControl = this.formControl || undefined\n\n        let finalMessage = \"\"\n\n        for (const validator of validators) {\n          const { isValid, message, invalidKeys } = validator.checkValidity(this)\n\n          if (isValid) { continue }\n\n          if (!finalMessage) {\n            finalMessage = message\n          }\n\n          if (invalidKeys?.length >= 0) {\n            // @ts-expect-error\n            invalidKeys.forEach((str) => flags[str] = true)\n          }\n        }\n\n        // This is a workaround for preserving custom errors\n        if (!finalMessage) {\n          finalMessage = this.validationMessage || this.__customErrorMessage\n        }\n\n        this.setValidity(flags, finalMessage, formControl)\n      }\n\n      updateInteractionState () {\n        if (this.disabled || this.hasAttribute(\"disabled\")) {\n          this.deleteCustomState(\"invalid\")\n          this.deleteCustomState(\"user-invalid\")\n          this.deleteCustomState(\"valid\")\n          this.deleteCustomState(\"user-valid\")\n          return\n        }\n\n        if (this.validity.valid) {\n          this.deleteCustomState(\"invalid\")\n          this.deleteCustomState(\"user-invalid\")\n          this.addCustomState(\"valid\")\n          this.toggleCustomState(\"user-valid\", this.hasInteracted && this.valueHasChanged)\n        } else {\n          this.deleteCustomState(\"valid\")\n          this.deleteCustomState(\"user-valid\")\n          this.addCustomState(\"invalid\")\n          this.toggleCustomState(\"user-invalid\", this.hasInteracted && this.valueHasChanged)\n        }\n      }\n    }\n  )\n}\n\n"],
  "mappings": "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",
  "names": ["VanillaFormAssociatedMixin", "superclass", "CustomStatesMixin", "FormAssociatedMixin", "args", "__publicField", "e", "parentAttrs", "validator", "attr", "ValueMissingValidator", "staticValidators", "validators", "message", "name", "oldVal", "newVal", "isDisabled", "state", "reason", "params", "flags", "anchor", "formControl", "finalMessage", "isValid", "invalidKeys", "str"]
}
